/*
 Generated by typeshare 1.9.2
*/

/** JSON containing an authentication token. */
export interface JwtResponse {
	/** A token the user can use to authenticate their requests. */
	jwt: string;
}

/** Response for [CreateLocalUser]. */
export type CreateLocalUserResponse = JwtResponse;

/** The response for [LoginLocalUser] */
export type LoginLocalUserResponse = JwtResponse;

/** Response for [ExchangeForJwt]. */
export type ExchangeForJwtResponse = JwtResponse;

export interface MongoIdObj {
	$oid: string;
}

export type MongoId = MongoIdObj;

export type UserConfig = 
	/** User that logs in with username / password */
	| { type: "Local", data: {
	password: string;
}}
	/** User that logs in via Google Oauth */
	| { type: "Google", data: {
	google_id: string;
	avatar: string;
}}
	/** User that logs in via Github Oauth */
	| { type: "Github", data: {
	github_id: string;
	avatar: string;
}}
	/** Non-human managed user, can have it's own permissions / api keys */
	| { type: "Service", data: {
	description: string;
}};

export type I64 = number;

export interface User {
	/**
	 * The Mongo ID of the User.
	 * This field is de/serialized from/to JSON as
	 * `{ "_id": { "$oid": "..." }, ...(rest of serialized User) }`
	 */
	_id?: MongoId;
	/** The globally unique username for the user. */
	username: string;
	/** Whether user is enabled / able to access the api. */
	enabled?: boolean;
	/** Whether the user has global admin permissions. */
	admin?: boolean;
	/** Whether the user has permission to create servers. */
	create_server_permissions?: boolean;
	/** Whether the user has permission to create builds */
	create_build_permissions?: boolean;
	/** The user-type specific config. */
	config: UserConfig;
	/** When the user last opened updates dropdown. */
	last_update_view?: I64;
	/** Recently viewed server ids */
	recent_servers?: string[];
	/** Recently viewed deployment ids */
	recent_deployments?: string[];
	/** Recently viewed build ids */
	recent_builds?: string[];
	/** Recently viewed repo ids */
	recent_repos?: string[];
	/** Recently viewed procedure ids */
	recent_procedures?: string[];
	updated_at?: I64;
}

export type GetUserResponse = User;

/** Represents an empty json object: `{}` */
export interface NoData {
}

export type CancelBuildResponse = NoData;

/** Severity level of problem. */
export enum SeverityLevel {
	/** No problem. */
	Ok = "OK",
	/** Problem is imminent. */
	Warning = "WARNING",
	/** Problem fully realized. */
	Critical = "CRITICAL",
}

export type ResourceTarget = 
	| { type: "System", id: string }
	| { type: "Build", id: string }
	| { type: "Builder", id: string }
	| { type: "Deployment", id: string }
	| { type: "Server", id: string }
	| { type: "Repo", id: string }
	| { type: "Alerter", id: string }
	| { type: "Procedure", id: string }
	| { type: "ServerTemplate", id: string };

/** The variants of data related to the alert. */
export type AlertData = 
	/** A server could not be reached. */
	| { type: "ServerUnreachable", data: {
	/** The id of the server */
	id: string;
	/** The name of the server */
	name: string;
	/** The region of the server */
	region?: string;
	/** The error data */
	err?: _Serror;
}}
	/** A server has high CPU usage. */
	| { type: "ServerCpu", data: {
	/** The id of the server */
	id: string;
	/** The name of the server */
	name: string;
	/** The region of the server */
	region?: string;
	/** The cpu usage percentage */
	percentage: number;
}}
	/** A server has high memory usage. */
	| { type: "ServerMem", data: {
	/** The id of the server */
	id: string;
	/** The name of the server */
	name: string;
	/** The region of the server */
	region?: string;
	/** The used memory */
	used_gb: number;
	/** The total memory */
	total_gb: number;
}}
	/** A server has high disk usage. */
	| { type: "ServerDisk", data: {
	/** The id of the server */
	id: string;
	/** The name of the server */
	name: string;
	/** The region of the server */
	region?: string;
	/** The mount path of the disk */
	path: string;
	/** The used portion of the disk in GB */
	used_gb: number;
	/** The total size of the disk in GB */
	total_gb: number;
}}
	/** A container's state has changed unexpectedly. */
	| { type: "ContainerStateChange", data: {
	/** The id of the deployment */
	id: string;
	/** The name of the deployment */
	name: string;
	/** The server id of server deployment is on */
	server_id: string;
	/** The server name */
	server_name: string;
	/** The previous container state */
	from: DeploymentState;
	/** The current container state */
	to: DeploymentState;
}}
	/** An AWS builder failed to terminate. */
	| { type: "AwsBuilderTerminationFailed", data: {
	/** The id of the aws instance which failed to terminate */
	instance_id: string;
	/** A reason for the failure */
	message: string;
}}
	/** A Hetzner builder failed to terminate. */
	| { type: "HetznerBuilderTerminationFailed", data: {
	/** The id of the server which failed to terminate */
	server_id: I64;
	/** A reason for the failure */
	message: string;
}}
	| { type: "None", data: {
}};

/** Representation of an alert in the system. */
export interface Alert {
	/**
	 * The Mongo ID of the alert.
	 * This field is de/serialized from/to JSON as
	 * `{ "_id": { "$oid": "..." }, ...(rest of serialized Alert) }`
	 */
	_id?: MongoId;
	/** Unix timestamp in milliseconds the alert was opened */
	ts: I64;
	/** Whether the alert is already resolved */
	resolved: boolean;
	/** The severity of the alert */
	level: SeverityLevel;
	/** The target of the alert */
	target: ResourceTarget;
	/** The type of alert, eg ServerUnreachable, ServerMem, ContainerStateChange */
	variant: AlertData["type"];
	/** The data attached to the alert */
	data: AlertData;
	/** The timestamp of alert resolution */
	resolved_ts?: I64;
}

export type GetAlertResponse = Alert;

export interface Resource<Config, Info> {
	/**
	 * The Mongo ID of the resource.
	 * This field is de/serialized from/to JSON as
	 * `{ "_id": { "$oid": "..." }, ...(rest of serialized Resource<T>) }`
	 */
	_id?: MongoId;
	/**
	 * The resource name.
	 * This is guaranteed unique among others of the same resource type.
	 */
	name: string;
	/** A description for the resource */
	description?: string;
	/** When description last updated */
	updated_at?: I64;
	/** Tag Ids */
	tags?: string[];
	/** Resource-specific information (not user configurable). */
	info?: Info;
	/** Resource-specific configuration. */
	config: Config;
}

export type AlerterConfig = 
	/** Send alert serialized to JSON to an http endpoint. */
	| { type: "Custom", params: CustomAlerterConfig }
	/** Send alert to a slack app */
	| { type: "Slack", params: SlackAlerterConfig };

export interface AlerterInfo {
	is_default?: boolean;
}

export type Alerter = Resource<AlerterConfig, AlerterInfo>;

export type GetAlerterResponse = Alerter;

export interface ResourceListItem<Info> {
	/** The resource id */
	id: string;
	/** The resource type, ie `Server` or `Deployment` */
	type: ResourceTarget["type"];
	/** The resource name */
	name: string;
	/** Tag Ids */
	tags: string[];
	/** Resource specific info */
	info: Info;
}

export interface AlerterListItemInfo {
	/** Whether alerter is enabled for sending alerts */
	enabled: boolean;
	/** Whether the alerter is the default */
	is_default: boolean;
	/** The type of the alerter, eg. Slack, Custom */
	alerter_type: string;
}

export type AlerterListItem = ResourceListItem<AlerterListItemInfo>;

export type ListAlertersResponse = AlerterListItem[];

export interface Version {
	major: number;
	minor: number;
	patch: number;
}

export interface SystemCommand {
	path?: string;
	command?: string;
}

export interface EnvironmentVar {
	variable: string;
	value: string;
}

/** The build configuration. */
export interface BuildConfig {
	/** Which builder is used to build the image. */
	builder_id?: string;
	/** Whether to skip secret interpolation in the build_args. */
	skip_secret_interp?: boolean;
	/** The current version of the build. */
	version?: Version;
	/** The Github repo used as the source of the build. */
	repo?: string;
	/** The branch of the repo. */
	branch: string;
	/** Optionally set a specific commit hash. */
	commit?: string;
	/**
	 * The github account used to clone (used to access private repos).
	 * Empty string is public clone (only public repos).
	 */
	github_account?: string;
	/**
	 * The dockerhub account used to push the image to dockerhub.
	 * Empty string means no dockerhub push (server local build).
	 */
	docker_account?: string;
	/**
	 * The docker organization which the image should be pushed under.
	 * Empty string means no organization.
	 */
	docker_organization?: string;
	/** The optional command run after repo clone and before docker build. */
	pre_build?: SystemCommand;
	/**
	 * The path of the docker build context relative to the root of the repo.
	 * Default: "." (the root of the repo).
	 */
	build_path: string;
	/** The path of the dockerfile relative to the build path. */
	dockerfile_path: string;
	/** Docker build arguments */
	build_args?: EnvironmentVar[];
	/** Docker labels */
	labels?: EnvironmentVar[];
	/** Any extra docker cli arguments to be included in the build command */
	extra_args?: string[];
	/** Whether to use buildx to build (eg `docker buildx build ...`) */
	use_buildx?: boolean;
	/** Whether incoming webhooks actually trigger action. */
	webhook_enabled: boolean;
}

export interface BuildInfo {
	last_built_at: I64;
}

export type Build = Resource<BuildConfig, BuildInfo>;

export type GetBuildResponse = Build;

export enum BuildState {
	/** Last build successful (or never built) */
	Ok = "Ok",
	/** Last build failed */
	Failed = "Failed",
	/** Currently building */
	Building = "Building",
	/** Other case */
	Unknown = "Unknown",
}

export interface BuildListItemInfo {
	/** Unix timestamp in milliseconds of last build */
	last_built_at: I64;
	/** The current version of the build */
	version: Version;
	/** The Github repo used as the source of the build */
	repo: string;
	/** The branch of the repo */
	branch: string;
	/** State of the build. Reflects whether most recent build successful. */
	state: BuildState;
}

export type BuildListItem = ResourceListItem<BuildListItemInfo>;

export type ListBuildsResponse = BuildListItem[];

export interface BuildActionState {
	building: boolean;
}

export type GetBuildActionStateResponse = BuildActionState;

export interface BuildVersionResponseItem {
	version: Version;
	ts: I64;
}

export type GetBuildVersionsResponse = BuildVersionResponseItem[];

export type ListDockerOrganizationsResponse = string[];

export type ListCommonBuildExtraArgsResponse = string[];

export type BuilderConfig = 
	/** Use a connected server an image builder. */
	| { type: "Server", params: ServerBuilderConfig }
	/** Use EC2 instances spawned on demand as an image builder. */
	| { type: "Aws", params: AwsBuilderConfig };

export type Builder = Resource<BuilderConfig, undefined>;

export type GetBuilderResponse = Builder;

export interface BuilderListItemInfo {
	builder_type: string;
	instance_type?: string;
}

export type BuilderListItem = ResourceListItem<BuilderListItemInfo>;

export type ListBuildersResponse = BuilderListItem[];

export type DeploymentImage = 
	/** Deploy any external image. */
	| { type: "Image", params: {
	/** The docker image, can be from any registry that works with docker and that the host server can reach. */
	image?: string;
}}
	/** Deploy a monitor build. */
	| { type: "Build", params: {
	/** The id of the build */
	build_id?: string;
	/**
	 * Use a custom / older version of the image produced by the build.
	 * if version is 0.0.0, this means `latest` image.
	 */
	version?: Version;
}};

export enum TerminationSignal {
	SigHup = "SIGHUP",
	SigInt = "SIGINT",
	SigQuit = "SIGQUIT",
	SigTerm = "SIGTERM",
}

export interface TerminationSignalLabel {
	signal: TerminationSignal;
	label: string;
}

export interface Conversion {
	/** reference on the server. */
	local: string;
	/** reference in the container. */
	container: string;
}

export enum RestartMode {
	NoRestart = "no",
	OnFailure = "on-failure",
	Always = "always",
	UnlessStopped = "unless-stopped",
}

export interface DeploymentConfig {
	/** The id of server the deployment is deployed on. */
	server_id?: string;
	/** Whether to send ContainerStateChange alerts for this deployment. */
	send_alerts: boolean;
	/**
	 * The image which the deployment deploys.
	 * Can either be a user inputted image, or a Monitor build.
	 */
	image?: DeploymentImage;
	/** Whether to skip secret interpolation into the deployment environment variables. */
	skip_secret_interp?: boolean;
	/** Whether to redeploy the deployment whenever the attached build finishes. */
	redeploy_on_build?: boolean;
	/**
	 * Labels attached to various termination signal options.
	 * Used to specify different shutdown functionality depending on the termination signal.
	 */
	term_signal_labels: TerminationSignalLabel[];
	/** The default termination signal to use to stop the deployment. Defaults to SigTerm (default docker signal). */
	termination_signal?: TerminationSignal;
	/** The termination timeout. */
	termination_timeout: number;
	/**
	 * The container port mapping.
	 * Irrelevant if container network is `host`.
	 * Maps ports on host to ports on container.
	 */
	ports?: Conversion[];
	/**
	 * The container volume mapping.
	 * Maps files / folders on host to files / folders in container.
	 */
	volumes?: Conversion[];
	/** The environment variables passed to the container. */
	environment?: EnvironmentVar[];
	/** The docker labels given to the container. */
	labels?: EnvironmentVar[];
	/**
	 * The network attached to the container.
	 * Default is `host`.
	 */
	network: string;
	/** The restart mode given to the container. */
	restart?: RestartMode;
	/**
	 * This is interpolated at the end of the `docker run` command,
	 * which means they are either passed to the containers inner process,
	 * or replaces the container command, depending on use of ENTRYPOINT or CMD in dockerfile.
	 * Empty is no command.
	 */
	command?: string;
	/**
	 * Extra args which are interpolated into the `docker run` command,
	 * and affect the container configuration.
	 */
	extra_args?: string[];
	/**
	 * The docker account the deployment should use to pull the image.
	 * - If using a custom image, empty string means don't use an account. Only works for public images.
	 * - If using a monitor build, empty string means to use the same docker account as the build uses.
	 */
	docker_account?: string;
}

export type Deployment = Resource<DeploymentConfig, undefined>;

export type GetDeploymentResponse = Deployment;

/**
 * Variants de/serialized from/to snake_case.
 * 
 * Eg.
 * - NotDeployed -> not_deployed
 * - Restarting -> restarting
 * - Running -> running.
 */
export enum DeploymentState {
	Unknown = "unknown",
	NotDeployed = "not_deployed",
	Created = "created",
	Restarting = "restarting",
	Running = "running",
	Removing = "removing",
	Paused = "paused",
	Exited = "exited",
	Dead = "dead",
}

export interface DeploymentListItemInfo {
	/** The state of the deployment / underlying docker container. */
	state: DeploymentState;
	/** The status of the docker container (eg. up 12 hours, exited 5 minutes ago.) */
	status?: string;
	/** The image attached to the deployment. */
	image: string;
	/** The server that deployment sits on. */
	server_id: string;
	/** An attached monitor build, if it exists. */
	build_id?: string;
}

export type DeploymentListItem = ResourceListItem<DeploymentListItemInfo>;

export type ListDeploymentsResponse = DeploymentListItem[];

export interface Log {
	stage: string;
	command: string;
	stdout: string;
	stderr: string;
	success: boolean;
	start_ts: I64;
	end_ts: I64;
}

export type GetLogResponse = Log;

export type SearchLogResponse = Log;

export interface DockerContainerStats {
	name: string;
	cpu_perc: string;
	mem_perc: string;
	mem_usage: string;
	net_io: string;
	block_io: string;
	pids: string;
}

export type GetDeploymentStatsResponse = DockerContainerStats;

export interface DeploymentActionState {
	deploying: boolean;
	stopping: boolean;
	starting: boolean;
	removing: boolean;
	renaming: boolean;
}

export type GetDeploymentActionStateResponse = DeploymentActionState;

export type ListCommonDeploymentExtraArgsResponse = string[];

export type UserTarget = 
	/** User Id */
	| { type: "User", id: string }
	/** UserGroup Id */
	| { type: "UserGroup", id: string };

/** The levels of permission that a User or UserGroup can have on a resource. */
export enum PermissionLevel {
	/** No permissions. */
	None = "None",
	/** Can see the rousource */
	Read = "Read",
	/** Can execute actions on the resource */
	Execute = "Execute",
	/** Can update the resource configuration */
	Write = "Write",
}

/** Representation of a User or UserGroups permission on a resource. */
export interface Permission {
	/** The id of the permission document */
	_id?: MongoId;
	/** The target User / UserGroup */
	user_target: UserTarget;
	/** The target resource */
	resource_target: ResourceTarget;
	/** The permission level */
	level?: PermissionLevel;
}

export type ListPermissionsResponse = Permission[];

export type GetPermissionLevelResponse = PermissionLevel;

export type ListUserTargetPermissionsResponse = Permission[];

export enum ProcedureType {
	/** Run the executions one after the other, in order of increasing index. */
	Sequence = "Sequence",
	/** Start all the executions simultaneously. */
	Parallel = "Parallel",
}

/** A wrapper for all monitor exections. */
export type Execution = 
	/** For new executions upon instantiation */
	| { type: "None", params: NoData }
	| { type: "RunProcedure", params: RunProcedure }
	| { type: "RunBuild", params: RunBuild }
	| { type: "Deploy", params: Deploy }
	| { type: "StartContainer", params: StartContainer }
	| { type: "StopContainer", params: StopContainer }
	| { type: "StopAllContainers", params: StopAllContainers }
	| { type: "RemoveContainer", params: RemoveContainer }
	| { type: "CloneRepo", params: CloneRepo }
	| { type: "PullRepo", params: PullRepo }
	| { type: "PruneDockerNetworks", params: PruneDockerNetworks }
	| { type: "PruneDockerImages", params: PruneDockerImages }
	| { type: "PruneDockerContainers", params: PruneDockerContainers };

/** Allows to enable / disabled procedures in the sequence / parallel vec on the fly */
export interface EnabledExecution {
	/** The execution request to run. */
	execution: Execution;
	/** Whether the execution is enabled to run in the procedure. */
	enabled: boolean;
}

export interface ProcedureConfig {
	/** Whether executions in the procedure runs sequentially or in parallel. */
	procedure_type?: ProcedureType;
	/** The executions to be run by the procedure. */
	executions?: EnabledExecution[];
	/** Whether incoming webhooks actually trigger action. */
	webhook_enabled: boolean;
}

export type Procedure = Resource<ProcedureConfig, undefined>;

export type GetProcedureResponse = Procedure;

export enum ProcedureState {
	/** Last run successful */
	Ok = "Ok",
	/** Last run failed */
	Failed = "Failed",
	/** Currently running */
	Running = "Running",
	/** Other case (never run) */
	Unknown = "Unknown",
}

export interface ProcedureListItemInfo {
	/** Sequence or Parallel. */
	procedure_type: ProcedureType;
	/** Reflect whether last run successful / currently running. */
	state: ProcedureState;
}

export type ProcedureListItem = ResourceListItem<ProcedureListItemInfo>;

export type ListProceduresResponse = ProcedureListItem[];

export interface ProcedureActionState {
	running: boolean;
}

export type GetProcedureActionStateResponse = ProcedureActionState;

export interface RepoConfig {
	/** The server to clone the repo on. */
	server_id?: string;
	/** The github repo to clone. */
	repo?: string;
	/** The repo branch. */
	branch: string;
	/** Optionally set a specific commit hash. */
	commit?: string;
	/**
	 * The github account to use to clone.
	 * It must be available in the server's periphery config.
	 */
	github_account?: string;
	/**
	 * Command to be run after the repo is cloned.
	 * The path is relative to the root of the repo.
	 */
	on_clone?: SystemCommand;
	/**
	 * Command to be run after the repo is pulled.
	 * The path is relative to the root of the repo.
	 */
	on_pull?: SystemCommand;
	/** Whether incoming webhooks actually trigger action. */
	webhook_enabled: boolean;
}

export interface RepoInfo {
	/** When repo was last pulled */
	last_pulled_at: I64;
}

export type Repo = Resource<RepoConfig, RepoInfo>;

export type GetRepoResponse = Repo;

export enum RepoState {
	/** Unknown case */
	Unknown = "Unknown",
	/** Last clone / pull successful (or never cloned) */
	Ok = "Ok",
	/** Last clone / pull failed */
	Failed = "Failed",
	/** Currently cloning */
	Cloning = "Cloning",
	/** Currently pullling */
	Pulling = "Pulling",
}

export interface RepoListItemInfo {
	/** The server that repo sits on. */
	server_id: string;
	/** Repo last cloned / pulled timestamp in ms. */
	last_pulled_at: I64;
	/** The configured github repo */
	repo: string;
	/** The configured branch */
	branch: string;
	/** The repo state */
	state: RepoState;
	/** If the repo is cloned, will be the latest short commit hash. */
	latest_hash?: string;
	/** If the repo is cloned, will be the latest commit message. */
	latest_message?: string;
}

export type RepoListItem = ResourceListItem<RepoListItemInfo>;

export type ListReposResponse = RepoListItem[];

export interface RepoActionState {
	/** Whether repo currently cloning */
	cloning: boolean;
	/** Whether repo currently pulling */
	pulling: boolean;
}

export type GetRepoActionStateResponse = RepoActionState;

/** Server configuration. */
export interface ServerConfig {
	/**
	 * The http address of the periphery client.
	 * Example: http://localhost:8120
	 */
	address: string;
	/**
	 * Whether a server is enabled.
	 * If a server is disabled,
	 * you won't be able to perform any actions on it or see deployment's status.
	 * default: true
	 */
	enabled: boolean;
	/**
	 * Whether to monitor any server stats beyond passing health check.
	 * default: true
	 */
	stats_monitoring: boolean;
	/**
	 * Whether to trigger 'docker image prune -a -f' every 24 hours.
	 * default: true
	 */
	auto_prune: boolean;
	/** Whether to send alerts about the servers reachability */
	send_unreachable_alerts: boolean;
	/** Whether to send alerts about the servers CPU status */
	send_cpu_alerts: boolean;
	/** Whether to send alerts about the servers MEM status */
	send_mem_alerts: boolean;
	/** Whether to send alerts about the servers DISK status */
	send_disk_alerts: boolean;
	/** An optional region label */
	region?: string;
	/** The percentage threshhold which triggers WARNING state for CPU. */
	cpu_warning: number;
	/** The percentage threshhold which triggers CRITICAL state for CPU. */
	cpu_critical: number;
	/** The percentage threshhold which triggers WARNING state for MEM. */
	mem_warning: number;
	/** The percentage threshhold which triggers CRITICAL state for MEM. */
	mem_critical: number;
	/** The percentage threshhold which triggers WARNING state for DISK. */
	disk_warning: number;
	/** The percentage threshhold which triggers CRITICAL state for DISK. */
	disk_critical: number;
}

export type Server = Resource<ServerConfig, undefined>;

export type GetServerResponse = Server;

export enum ServerState {
	/** Server is unreachable. */
	NotOk = "NotOk",
	/** Server health check passing. */
	Ok = "Ok",
	/** Server is disabled. */
	Disabled = "Disabled",
}

export interface ServerListItemInfo {
	/** The server's state. */
	state: ServerState;
	/** Region of the server. */
	region: string;
	/** Whether server is configured to send unreachable alerts. */
	send_unreachable_alerts: boolean;
	/** Whether server is configured to send cpu alerts. */
	send_cpu_alerts: boolean;
	/** Whether server is configured to send mem alerts. */
	send_mem_alerts: boolean;
	/** Whether server is configured to send disk alerts. */
	send_disk_alerts: boolean;
}

export type ServerListItem = ResourceListItem<ServerListItemInfo>;

export type ListServersResponse = ServerListItem[];

/** Current pending actions on the server. */
export interface ServerActionState {
	/** Server currently pruning networks */
	pruning_networks: boolean;
	/** Server currently pruning containers */
	pruning_containers: boolean;
	/** Server currently pruning images */
	pruning_images: boolean;
	/** Server currently stopping all containers. */
	stopping_containers: boolean;
}

export type GetServerActionStateResponse = ServerActionState;

/** Ipam Configuration. */
export interface IpamConfig {
	Subnet?: string;
	IPRange?: string;
	Gateway?: string;
	AuxiliaryAddresses?: Record<string, string>;
}

/** Ipam related information */
export interface Ipam {
	/** Name of the IPAM driver to use. */
	Driver?: string;
	/** List of IPAM configuration options, specified as a map:  ``` {\"Subnet\": <CIDR>, \"IPRange\": <CIDR>, \"Gateway\": <IP address>, \"AuxAddress\": <device_name:IP address>} ``` */
	Config?: IpamConfig[];
	/** Driver-specific options, specified as a map. */
	Options?: Record<string, string>;
}

/** A container on a network. */
export interface NetworkContainer {
	Name?: string;
	EndpointID?: string;
	MacAddress?: string;
	IPv4Address?: string;
	IPv6Address?: string;
}

/** Summary of a docker network on a server. */
export interface DockerNetwork {
	/** The name of the docker network */
	Name?: string;
	/** The Id of the docker network */
	Id?: string;
	/** Timestamp network created */
	Created?: string;
	Scope?: string;
	Driver?: string;
	EnableIPv6?: boolean;
	IPAM?: Ipam;
	Internal?: boolean;
	Attachable?: boolean;
	Ingress?: boolean;
	Containers?: Record<string, NetworkContainer>;
	Options?: Record<string, string>;
	Labels?: Record<string, string>;
}

export type GetDockerNetworksResponse = DockerNetwork[];

/** Summary of a docker image cached on a server */
export interface ImageSummary {
	/** ID is the content-addressable ID of an image.  This identifier is a content-addressable digest calculated from the image's configuration (which includes the digests of layers used by the image).  Note that this digest differs from the `RepoDigests` below, which holds digests of image manifests that reference the image. */
	Id: string;
	/** ID of the parent image.  Depending on how the image was created, this field may be empty and is only set for images that were built/created locally. This field is empty if the image was pulled from an image registry. */
	ParentId: string;
	/** List of image names/tags in the local image cache that reference this image.  Multiple image tags can refer to the same image, and this list may be empty if no tags reference the image, in which case the image is \"untagged\", in which case it can still be referenced by its ID. */
	RepoTags: string[];
	/** List of content-addressable digests of locally available image manifests that the image is referenced from. Multiple manifests can refer to the same image.  These digests are usually only available if the image was either pulled from a registry, or if the image was pushed to a registry, which is when the manifest is generated and its digest calculated. */
	RepoDigests: string[];
	/** Date and time at which the image was created as a Unix timestamp (number of seconds sinds EPOCH). */
	Created: I64;
	/** Total size of the image including all layers it is composed of. */
	Size: I64;
	/** Total size of image layers that are shared between this image and other images.  This size is not calculated by default. `-1` indicates that the value has not been set / calculated. */
	SharedSize: I64;
	/** Total size of the image including all layers it is composed of.  In versions of Docker before v1.10, this field was calculated from the image itself and all of its parent images. Docker v1.10 and up store images self-contained, and no longer use a parent-chain, making this field an equivalent of the Size field.  This field is kept for backward compatibility, but may be removed in a future version of the API. */
	VirtualSize?: I64;
	/** User-defined key/value metadata. */
	Labels: Record<string, string>;
	/** Number of containers using this image. Includes both stopped and running containers.  This size is not calculated by default, and depends on which API endpoint is used. `-1` indicates that the value has not been set / calculated. */
	Containers: I64;
}

export type GetDockerImagesResponse = ImageSummary[];

/** A summary of a docker container on a server. */
export interface ContainerSummary {
	/** Name of the container. */
	name: string;
	/** Id of the container. */
	id: string;
	/** The image the container is based on. */
	image: string;
	/** The docker labels on the container. */
	labels: Record<string, string>;
	/** The state of the container, like `running` or `not_deployed` */
	state: DeploymentState;
	/** The status string of the docker container. */
	status?: string;
}

export type GetDockerContainersResponse = ContainerSummary[];

/** System information of a server */
export interface SystemInformation {
	/** The system name */
	name?: string;
	/** The system long os version */
	os?: string;
	/** System's kernel version */
	kernel?: string;
	/** Physical core count */
	core_count?: number;
	/** System hostname based off DNS */
	host_name?: string;
	/** The CPU's brand */
	cpu_brand: string;
}

export type GetSystemInformationResponse = SystemInformation;

/** Info for a single disk mounted on the system. */
export interface SingleDiskUsage {
	/** The mount point of the disk */
	mount: string;
	/** Detected file system */
	file_system: string;
	/** Used portion of the disk in GB */
	used_gb: number;
	/** Total size of the disk in GB */
	total_gb: number;
}

export enum Timelength {
	OneSecond = "1-sec",
	FiveSeconds = "5-sec",
	TenSeconds = "10-sec",
	FifteenSeconds = "15-sec",
	ThirtySeconds = "30-sec",
	OneMinute = "1-min",
	TwoMinutes = "2-min",
	FiveMinutes = "5-min",
	TenMinutes = "10-min",
	FifteenMinutes = "15-min",
	ThirtyMinutes = "30-min",
	OneHour = "1-hr",
	TwoHours = "2-hr",
	SixHours = "6-hr",
	EightHours = "8-hr",
	TwelveHours = "12-hr",
	OneDay = "1-day",
	ThreeDay = "3-day",
	OneWeek = "1-wk",
	TwoWeeks = "2-wk",
	ThirtyDays = "30-day",
}

/** Realtime system stats data. */
export interface SystemStats {
	/** Cpu usage percentage */
	cpu_perc: number;
	/** Memory used in GB */
	mem_used_gb: number;
	/** Total memory in GB */
	mem_total_gb: number;
	/** Breakdown of individual disks, ie their usages, sizes, and mount points */
	disks: SingleDiskUsage[];
	/** The rate the system stats are being polled from the system */
	polling_rate: Timelength;
	/** Unix timestamp in milliseconds when stats were last polled */
	refresh_ts: I64;
	/** Unix timestamp in milliseconds when disk list was last refreshed */
	refresh_list_ts: I64;
}

export type GetSystemStatsResponse = SystemStats;

/** Information about a process on the system. */
export interface SystemProcess {
	/** The process PID */
	pid: number;
	/** The process name */
	name: string;
	/** The path to the process executable */
	exe?: string;
	/** The command used to start the process */
	cmd: string[];
	/** The time the process was started */
	start_time?: number;
	/**
	 * The cpu usage percentage of the process.
	 * This is in core-percentage, eg 100% is 1 full core, and
	 * an 8 core machine would max at 800%.
	 */
	cpu_perc: number;
	/** The memory usage of the process in MB */
	mem_mb: number;
	/** Process disk read in KB/s */
	disk_read_kb: number;
	/** Process disk write in KB/s */
	disk_write_kb: number;
}

export type GetSystemProcessesResponse = SystemProcess[];

export type GetAvailableSecretsResponse = string[];

export type ServerTemplateConfig = 
	/** Template to launch an AWS EC2 instance */
	| { type: "Aws", params: AwsServerTemplateConfig }
	/** Template to launch a Hetzner server */
	| { type: "Hetzner", params: HetznerServerTemplateConfig };

export type ServerTemplate = Resource<ServerTemplateConfig, undefined>;

export type GetServerTemplateResponse = ServerTemplate;

export interface ServerTemplateListItemInfo {
	/** The cloud provider */
	provider: string;
	/** The instance type, eg c5.2xlarge on for Aws templates */
	instance_type?: string;
}

export type ServerTemplateListItem = ResourceListItem<ServerTemplateListItemInfo>;

export type ListServerTemplatesResponse = ServerTemplateListItem[];

export interface Tag {
	/**
	 * The Mongo ID of the tag.
	 * This field is de/serialized from/to JSON as
	 * `{ "_id": { "$oid": "..." }, ...(rest of serialized Tag) }`
	 */
	_id?: MongoId;
	name: string;
	owner?: string;
}

export type GetTagResponse = Tag;

export type ListTagsResponse = Tag[];

/** Response containing pretty formatted toml contents. */
export interface TomlResponse {
	toml: string;
}

export type ExportAllResourcesToTomlResponse = TomlResponse;

export type ExportResourcesToTomlResponse = TomlResponse;

export enum Operation {
	None = "None",
	CreateServer = "CreateServer",
	UpdateServer = "UpdateServer",
	DeleteServer = "DeleteServer",
	RenameServer = "RenameServer",
	PruneImagesServer = "PruneImagesServer",
	PruneContainersServer = "PruneContainersServer",
	PruneNetworksServer = "PruneNetworksServer",
	CreateNetwork = "CreateNetwork",
	DeleteNetwork = "DeleteNetwork",
	StopAllContainers = "StopAllContainers",
	CreateBuild = "CreateBuild",
	UpdateBuild = "UpdateBuild",
	DeleteBuild = "DeleteBuild",
	RunBuild = "RunBuild",
	CancelBuild = "CancelBuild",
	CreateBuilder = "CreateBuilder",
	UpdateBuilder = "UpdateBuilder",
	DeleteBuilder = "DeleteBuilder",
	CreateDeployment = "CreateDeployment",
	UpdateDeployment = "UpdateDeployment",
	DeleteDeployment = "DeleteDeployment",
	DeployContainer = "DeployContainer",
	StopContainer = "StopContainer",
	StartContainer = "StartContainer",
	RemoveContainer = "RemoveContainer",
	RenameDeployment = "RenameDeployment",
	CreateRepo = "CreateRepo",
	UpdateRepo = "UpdateRepo",
	DeleteRepo = "DeleteRepo",
	CloneRepo = "CloneRepo",
	PullRepo = "PullRepo",
	CreateAlerter = "CreateAlerter",
	UpdateAlerter = "UpdateAlerter",
	DeleteAlerter = "DeleteAlerter",
	CreateProcedure = "CreateProcedure",
	UpdateProcedure = "UpdateProcedure",
	DeleteProcedure = "DeleteProcedure",
	RunProcedure = "RunProcedure",
	CreateServerTemplate = "CreateServerTemplate",
	UpdateServerTemplate = "UpdateServerTemplate",
	DeleteServerTemplate = "DeleteServerTemplate",
	LaunchServer = "LaunchServer",
	CreateVariable = "CreateVariable",
	UpdateVariableValue = "UpdateVariableValue",
	DeleteVariable = "DeleteVariable",
}

export enum UpdateStatus {
	Queued = "Queued",
	InProgress = "InProgress",
	Complete = "Complete",
}

export interface Update {
	/**
	 * The Mongo ID of the update.
	 * This field is de/serialized from/to JSON as
	 * `{ "_id": { "$oid": "..." }, ...(rest of serialized Update) }`
	 */
	_id?: MongoId;
	operation: Operation;
	start_ts: I64;
	success: boolean;
	operator: string;
	target: ResourceTarget;
	logs: Log[];
	end_ts?: I64;
	status: UpdateStatus;
	version: Version;
}

export type GetUpdateResponse = Update;

/** An api key used to authenticate requests via request headers. */
export interface ApiKey {
	/** Unique key associated with secret */
	key: string;
	/** Hash of the secret */
	secret: string;
	/** User associated with the api key */
	user_id: string;
	/** Name associated with the api key for management */
	name: string;
	/** Timestamp of key creation */
	created_at: I64;
	/** Expiry of key, or 0 if never expires */
	expires: I64;
}

export type ListApiKeysResponse = ApiKey[];

export type ListApiKeysForServiceUserResponse = ApiKey[];

export type ListUsersResponse = User[];

export interface UserGroup {
	/**
	 * The Mongo ID of the UserGroup.
	 * This field is de/serialized from/to JSON as
	 * `{ "_id": { "$oid": "..." }, ...(rest of serialized User) }`
	 */
	_id?: MongoId;
	name: string;
	/** User ids */
	users: string[];
	updated_at?: I64;
}

export type GetUserGroupResponse = UserGroup;

export type ListUserGroupsResponse = UserGroup[];

/**
 * A non-secret global variable which can be interpolated into deployment
 * environment variable values and build argument values.
 */
export interface Variable {
	/**
	 * Unique name associated with the variable.
	 * Instances of '[[variable.name]]' in value will be replaced with 'variable.value'.
	 */
	name: string;
	/** The value associated with the variable. */
	value: string;
	/** A description for the variable. */
	description: string;
}

export type GetVariableResponse = Variable;

export type DeleteApiKeyResponse = NoData;

/** Response for [CreateApiKey]. */
export interface CreateApiKeyResponse {
	/** X-API-KEY */
	key: string;
	/**
	 * X-API-SECRET
	 * 
	 * Note.
	 * There is no way to get the secret again after it is distributed in this message
	 */
	secret: string;
}

export type CreateApiKeyForServiceUserResponse = CreateApiKeyResponse;

export type DeleteApiKeyForServiceUserResponse = NoData;

export type UpdateDescriptionResponse = NoData;

export type UpdatePermissionOnTargetResponse = NoData;

export type UpdateUserBasePermissionsResponse = NoData;

export type CreateProcedureResponse = Procedure;

export type CopyProcedureResponse = Procedure;

export type DeleteProcedureResponse = Procedure;

export type UpdateProcedureResponse = Procedure;

export type UpdateTagsOnResourceResponse = NoData;

export type PushRecentlyViewedResponse = NoData;

export type SetLastSeenUpdateResponse = NoData;

export type CreateServiceUserResponse = User;

export type UpdateServiceUserDescriptionResponse = User;

export type CreateVariableResponse = Variable;

export type UpdateVariableValueResponse = Variable;

export type UpdateVariableDescriptionResponse = Variable;

export type DeleteVariableResponse = Variable;

export type _PartialCustomAlerterConfig = Partial<CustomAlerterConfig>;

export type _PartialSlackAlerterConfig = Partial<SlackAlerterConfig>;

export enum TagBehavior {
	/** Returns resources which have strictly all the tags */
	All = "All",
	/** Returns resources which have one or more of the tags */
	Any = "Any",
}

/** Passing empty Vec is the same as not filtering by that field */
export interface ResourceQuery<T> {
	ids?: string[];
	names?: string[];
	/** Pass Vec of tag ids or tag names */
	tags?: string[];
	tag_behavior?: TagBehavior;
	specific?: T;
}

export interface AlerterQuerySpecifics {
	types: AlerterConfig["type"][];
}

export type AlerterQuery = ResourceQuery<AlerterQuerySpecifics>;

export type _PartialBuildConfig = Partial<BuildConfig>;

export interface BuildQuerySpecifics {
	builder_ids?: string[];
	repos?: string[];
	/**
	 * query for builds last built more recently than this timestamp
	 * defaults to 0 which is a no op
	 */
	built_since?: I64;
}

export type BuildQuery = ResourceQuery<BuildQuerySpecifics>;

export type _PartialBuilderConfig = Partial<BuilderConfig>;

export type _PartialServerBuilderConfig = Partial<ServerBuilderConfig>;

export type _PartialAwsBuilderConfig = Partial<AwsBuilderConfig>;

export interface BuilderQuerySpecifics {
}

export type BuilderQuery = ResourceQuery<BuilderQuerySpecifics>;

export type _PartialDeploymentConfig = Partial<DeploymentConfig>;

export interface DeploymentQuerySpecifics {
	server_ids?: string[];
	build_ids?: string[];
}

export type DeploymentQuery = ResourceQuery<DeploymentQuerySpecifics>;

export type U64 = number;

export type MongoDocument = any;

export interface __Serror {
	error: string;
	trace: string[];
}

export type _Serror = __Serror;

export type _PartialProcedureConfig = Partial<ProcedureConfig>;

export interface ProcedureQuerySpecifics {
	types: ProcedureType[];
}

export type ProcedureQuery = ResourceQuery<ProcedureQuerySpecifics>;

export type _PartialRepoConfig = Partial<RepoConfig>;

export interface RepoQuerySpecifics {
	/** Filter builds by their repo. */
	repos: string[];
}

export type RepoQuery = ResourceQuery<RepoQuerySpecifics>;

export type _PartialServerConfig = Partial<ServerConfig>;

export interface ServerQuerySpecifics {
}

/** Server-specific query */
export type ServerQuery = ResourceQuery<ServerQuerySpecifics>;

export type _PartialAwsServerTemplateConfig = Partial<AwsServerTemplateConfig>;

export type _PartialHetznerServerTemplateConfig = Partial<HetznerServerTemplateConfig>;

export interface ServerTemplateQuerySpecifics {
	types: ServerTemplateConfig["type"][];
}

export type ServerTemplateQuery = ResourceQuery<ServerTemplateQuerySpecifics>;

export type _PartialTag = Partial<Tag>;

/**
 * Non authenticated route to see the available options
 * users have to login to monitor, eg. local auth, github, google.
 * Response: [GetLoginOptionsResponse].
 */
export interface GetLoginOptions {
}

/** The response for [GetLoginOptions]. */
export interface GetLoginOptionsResponse {
	/** Whether local auth is enabled. */
	local: boolean;
	/** Whether github login is enabled. */
	github: boolean;
	/** Whether google login is enabled. */
	google: boolean;
}

/**
 * Create a new local user account. Will fail if a user with the
 * given username already exists.
 * Response: [CreateLocalUserResponse].
 * 
 * Note. This method is only available if the core api has `local_auth` enabled.
 */
export interface CreateLocalUser {
	/** The username for the new user. */
	username: string;
	/**
	 * The password for the new user.
	 * This cannot be retreived later.
	 */
	password: string;
}

/**
 * Login as a local user. Will fail if the users credentials don't match
 * any local user.
 * 
 * Note. This method is only available if the core api has `local_auth` enabled.
 */
export interface LoginLocalUser {
	/** The user's username */
	username: string;
	/** The user's password */
	password: string;
}

/**
 * Exchange a single use exchange token (safe for transport in url query)
 * for a jwt.
 * Response: [ExchangeForJwtResponse].
 */
export interface ExchangeForJwt {
	/** The 'exchange token' */
	token: string;
}

/**
 * Get the user extracted from the request headers.
 * Response: [User].
 */
export interface GetUser {
}

/**
 * Executes the target build. Response: [Update].
 * 
 * 1. Get a handle to the builder. If using AWS builder, this means starting a builder ec2 instance.
 * 2. Clone the repo on the builder. If an `on_clone` commmand is given, it will be executed.
 * 3. Execute `docker build {...params}`, where params are determined using the builds configuration.
 * 4. If a dockerhub account is attached, the build will be pushed to that account.
 */
export interface RunBuild {
	/** Can be build id or name */
	build: string;
}

/**
 * Cancels the target build.
 * Only does anything if the build is `building` when called.
 * Response: [Update]
 */
export interface CancelBuild {
	/** Can be id or name */
	build: string;
}

/**
 * Deploys the container for the target deployment. Response: [Update].
 * 
 * 1. Pulls the image onto the target server.
 * 2. If the container is already running,
 * it will be stopped and removed using `docker container rm ${container_name}`.
 * 3. The container will be run using `docker run {...params}`,
 * where params are determined by the deployment's configuration.
 */
export interface Deploy {
	/** Name or id */
	deployment: string;
	/** Override the default termination signal specified in the deployment. */
	stop_signal?: TerminationSignal;
	/** Override the default termination max time. */
	stop_time?: number;
}

/**
 * Starts the container for the target deployment. Response: [Update]
 * 
 * 1. Runs `docker start ${container_name}`.
 */
export interface StartContainer {
	/** Name or id */
	deployment: string;
}

/**
 * Stops the container for the target deployment. Response: [Update]
 * 
 * 1. Runs `docker stop ${container_name}`.
 */
export interface StopContainer {
	/** Name or id */
	deployment: string;
	/** Override the default termination signal specified in the deployment. */
	signal?: TerminationSignal;
	/** Override the default termination max time. */
	time?: number;
}

/**
 * Stops all deployments on the target server. Response: [Update]
 * 
 * 1. Runs [StopContainer] on all deployments on the server concurrently.
 */
export interface StopAllContainers {
	/** Name or id */
	server: string;
}

/**
 * Stops and removes the container for the target deployment.
 * Reponse: [Update].
 * 
 * 1. The container is stopped and removed using `docker container rm ${container_name}`.
 */
export interface RemoveContainer {
	/** Name or id. */
	deployment: string;
	/** Override the default termination signal specified in the deployment. */
	signal?: TerminationSignal;
	/** Override the default termination max time. */
	time?: number;
}

/** Runs the target procedure. Response: [Update] */
export interface RunProcedure {
	/** Id or name */
	procedure: string;
}

/**
 * Clones the target repo. Response: [Update].
 * 
 * 1. Clones the repo on the target server using `git clone https://{$token?}@github.com/${repo} -b ${branch}`.
 * The token will only be used if a github account is specified,
 * and must be declared in the periphery configuration on the target server.
 * 2. If `on_clone` and `on_pull` are specified, they will be executed.
 * `on_clone` will be executed before `on_pull`.
 */
export interface CloneRepo {
	/** Id or name */
	repo: string;
}

/**
 * Pulls the target repo. Response: [Update].
 * 
 * 1. Pulls the repo on the target server using `git pull`.
 * 2. If `on_pull` is specified, it will be executed after the pull is complete.
 */
export interface PullRepo {
	/** Id or name */
	repo: string;
}

/**
 * Prunes the docker networks on the target server. Response: [Update].
 * 
 * 1. Runs `docker network prune -f`.
 */
export interface PruneDockerNetworks {
	/** Id or name */
	server: string;
}

/**
 * Prunes the docker images on the target server. Response: [Update].
 * 
 * 1. Runs `docker image prune -a -f`.
 */
export interface PruneDockerImages {
	/** Id or name */
	server: string;
}

/**
 * Prunes the docker containers on the target server. Response: [Update].
 * 
 * 1. Runs `docker container prune -f`.
 */
export interface PruneDockerContainers {
	/** Id or name */
	server: string;
}

/**
 * Launch an EC2 instance with the specified config.
 * Response: [Update].
 */
export interface LaunchServer {
	/** The name of the created server. */
	name: string;
	/** The server template used to define the config. */
	server_template: string;
}

/**
 * Get a paginated list of alerts sorted by timestamp descending.
 * Response: [ListAlertsResponse].
 */
export interface ListAlerts {
	/**
	 * Pass a custom mongo query to filter the alerts.
	 * 
	 * ## Example JSON
	 * ```
	 * {
	 * "resolved": "false",
	 * "level": "CRITICAL",
	 * "$or": [
	 * {
	 * "target": {
	 * "type": "Server",
	 * "id": "6608bf89cb2a12b257ab6c09"
	 * }
	 * },
	 * {
	 * "target": {
	 * "type": "Server",
	 * "id": "660a5f60b74f90d5dae45fa3"
	 * }
	 * }
	 * ]
	 * }
	 * ```
	 * This will filter to only include open alerts that have CRITICAL level on those two servers.
	 */
	query?: MongoDocument;
	/**
	 * Retrieve older results by incrementing the page.
	 * `page: 0` is default, and returns the most recent results.
	 */
	page?: U64;
}

/** Response for [ListAlerts]. */
export interface ListAlertsResponse {
	alerts: Alert[];
	/**
	 * If more alerts exist, the next page will be given here.
	 * Otherwise it will be `null`
	 */
	next_page?: I64;
}

/** Get an alert: Response: [Alert]. */
export interface GetAlert {
	id: string;
}

/** Get a specific alerter. Response: [Alerter]. */
export interface GetAlerter {
	/** Id or name */
	alerter: string;
}

/** List alerters matching optional query. Response: [ListAlertersResponse]. */
export interface ListAlerters {
	/** Structured query to filter alerters. */
	query?: AlerterQuery;
}

/**
 * Gets a summary of data relating to all alerters.
 * Response: [GetAlertersSummaryResponse].
 */
export interface GetAlertersSummary {
}

/** Response for [GetAlertersSummary]. */
export interface GetAlertersSummaryResponse {
	total: number;
}

/** Get a specific build. Response: [Build]. */
export interface GetBuild {
	/** Id or name */
	build: string;
}

/** List builds matching optional query. Response: [ListBuildsResponse]. */
export interface ListBuilds {
	/** optional structured query to filter builds. */
	query?: BuildQuery;
}

/** Get current action state for the build. Response: [BuildActionState]. */
export interface GetBuildActionState {
	/** Id or name */
	build: string;
}

/**
 * Gets a summary of data relating to all builds.
 * Response: [GetBuildsSummaryResponse].
 */
export interface GetBuildsSummary {
}

/** Response for [GetBuildsSummary]. */
export interface GetBuildsSummaryResponse {
	/** The total number of builds in monitor. */
	total: number;
	/** The number of builds with Ok state. */
	ok: number;
	/** The number of builds with Failed state. */
	failed: number;
	/** The number of builds currently building. */
	building: number;
	/** The number of builds with unknown state. */
	unknown: number;
}

/**
 * Gets summary and timeseries breakdown of the last months build count / time for charting.
 * Response: [GetBuildMonthlyStatsResponse].
 * 
 * Note. This method is paginated. One page is 30 days of data.
 * Query for older pages by incrementing the page, starting at 0.
 */
export interface GetBuildMonthlyStats {
	/**
	 * Query for older data by incrementing the page.
	 * `page: 0` is the default, and will return the most recent data.
	 */
	page?: number;
}

/** Item in [GetBuildMonthlyStatsResponse] */
export interface BuildStatsDay {
	time: number;
	count: number;
	ts: number;
}

/** Response for [GetBuildMonthlyStats]. */
export interface GetBuildMonthlyStatsResponse {
	total_time: number;
	total_count: number;
	days: BuildStatsDay[];
}

/**
 * Retrieve versions of the build that were built in the past and available for deployment,
 * sorted by most recent first.
 * Response: [GetBuildVersionsResponse].
 */
export interface GetBuildVersions {
	/** Id or name */
	build: string;
	/** Filter to only include versions matching this major version. */
	major?: number;
	/** Filter to only include versions matching this minor version. */
	minor?: number;
	/** Filter to only include versions matching this patch version. */
	patch?: number;
}

/**
 * List the available docker organizations which can be attached to builds.
 * Response: [ListDockerOrganizationsResponse].
 */
export interface ListDockerOrganizations {
}

/**
 * Gets a list of existing values used as extra args across other builds.
 * Useful to offer suggestions. Response: [ListCommonBuildExtraArgsResponse]
 */
export interface ListCommonBuildExtraArgs {
	/** optional structured query to filter builds. */
	query?: BuildQuery;
}

/** Get a specific builder by id or name. Response: [Builder]. */
export interface GetBuilder {
	/** Id or name */
	builder: string;
}

/** List builders matching structured query. Response: [ListBuildersResponse]. */
export interface ListBuilders {
	query?: BuilderQuery;
}

/**
 * Gets a summary of data relating to all builders.
 * Response: [GetBuildersSummaryResponse].
 */
export interface GetBuildersSummary {
}

/** Response for [GetBuildersSummary]. */
export interface GetBuildersSummaryResponse {
	/** The total number of builders. */
	total: number;
}

/**
 * Get the docker / github accounts which are available for use on the builder.
 * Response: [GetBuilderAvailableAccountsResponse].
 * 
 * Note. Builds using this builder can only use the docker / github accounts available in this response.
 */
export interface GetBuilderAvailableAccounts {
	/** Id or name */
	builder: string;
}

/** Response for [GetBuilderAvailableAccounts]. */
export interface GetBuilderAvailableAccountsResponse {
	github: string[];
	docker: string[];
}

/** Get a specific deployment by name or id. Response: [Deployment]. */
export interface GetDeployment {
	/** Id or name */
	deployment: string;
}

/**
 * List deployments matching optional query.
 * Response: [ListDeploymentsResponse].
 */
export interface ListDeployments {
	/** optional structured query to filter deployments. */
	query?: DeploymentQuery;
}

/**
 * Get the container, including image / status, of the target deployment.
 * Response: [GetDeploymentContainerResponse].
 * 
 * Note. This does not hit the server directly. The status comes from an
 * in memory cache on the core, which hits the server periodically
 * to keep it up to date.
 */
export interface GetDeploymentContainer {
	/** Id or name */
	deployment: string;
}

/** Response for [GetDeploymentContainer]. */
export interface GetDeploymentContainerResponse {
	state: DeploymentState;
	container?: ContainerSummary;
}

/**
 * Get the deployment log's tail, split by stdout/stderr.
 * Response: [Log].
 * 
 * Note. This call will hit the underlying server directly for most up to date log.
 */
export interface GetLog {
	/** Id or name */
	deployment: string;
	/**
	 * The number of lines of the log tail to include.
	 * Default: 100.
	 * Max: 5000.
	 */
	tail: U64;
}

export enum SearchCombinator {
	Or = "Or",
	And = "And",
}

/**
 * Search the deployment log's tail using `grep`. All lines go to stdout.
 * Response: [Log].
 * 
 * Note. This call will hit the underlying server directly for most up to date log.
 */
export interface SearchLog {
	/** Id or name */
	deployment: string;
	/** The terms to search for. */
	terms: string[];
	/**
	 * When searching for multiple terms, can use `AND` or `OR` combinator.
	 * 
	 * - `AND`: Only include lines with **all** terms present in that line.
	 * - `OR`: Include lines that have one or more matches in the terms.
	 */
	combinator?: SearchCombinator;
}

/**
 * Get the deployment container's stats using `docker stats`.
 * Response: [DockerContainerStats].
 * 
 * Note. This call will hit the underlying server directly for most up to date stats.
 */
export interface GetDeploymentStats {
	/** Id or name */
	deployment: string;
}

/**
 * Get current action state for the deployment.
 * Response: [DeploymentActionState].
 */
export interface GetDeploymentActionState {
	/** Id or name */
	deployment: string;
}

/**
 * Gets a summary of data relating to all deployments.
 * Response: [GetDeploymentsSummaryResponse].
 */
export interface GetDeploymentsSummary {
}

/** Response for [GetDeploymentsSummary]. */
export interface GetDeploymentsSummaryResponse {
	total: I64;
	running: I64;
	stopped: I64;
	not_deployed: I64;
	unknown: I64;
}

/**
 * Gets a list of existing values used as extra args across other deployments.
 * Useful to offer suggestions. Response: [ListCommonDeploymentExtraArgsResponse]
 */
export interface ListCommonDeploymentExtraArgs {
	/** optional structured query to filter deployments. */
	query?: DeploymentQuery;
}

/**
 * Get the version of the core api.
 * Response: [GetVersionResponse].
 */
export interface GetVersion {
}

/** Response for [GetVersion]. */
export interface GetVersionResponse {
	/** The version of the core api. */
	version: string;
}

/**
 * Get info about the core api.
 * Response: [GetCoreInfoResponse].
 */
export interface GetCoreInfo {
}

/** Response for [GetCoreInfo]. */
export interface GetCoreInfoResponse {
	/** The title assigned to this core api. */
	title: string;
	/** The monitoring interval of this core api. */
	monitoring_interval: Timelength;
	/** The github webhook base url to use with github webhooks. */
	github_webhook_base_url: string;
	/** Whether transparent mode is enabled, which gives all users read access to all resources. */
	transparent_mode: boolean;
}

/**
 * List permissions for the calling user.
 * Does not include any permissions on UserGroups they may be a part of.
 * Response: [ListPermissionsResponse]
 */
export interface ListPermissions {
}

/**
 * Gets the calling user's permission level on a specific resource.
 * Factors in any UserGroup's permissions they may be a part of.
 * Response: [PermissionLevel]
 */
export interface GetPermissionLevel {
	/** The target to get user permission on. */
	target: ResourceTarget;
}

/**
 * List permissions for a specific user. **Admin only**.
 * Response: [ListUserTargetPermissionsResponse]
 */
export interface ListUserTargetPermissions {
	/** Specify either a user or a user group. */
	user_target: UserTarget;
}

/** Get a specific procedure. Response: [Procedure]. */
export interface GetProcedure {
	/** Id or name */
	procedure: string;
}

/** List procedures matching optional query. Response: [ListProceduresResponse]. */
export interface ListProcedures {
	/** optional structured query to filter procedures. */
	query?: ProcedureQuery;
}

/** Get current action state for the procedure. Response: [ProcedureActionState]. */
export interface GetProcedureActionState {
	/** Id or name */
	procedure: string;
}

/**
 * Gets a summary of data relating to all procedures.
 * Response: [GetProceduresSummaryResponse].
 */
export interface GetProceduresSummary {
}

/** Response for [GetProceduresSummary]. */
export interface GetProceduresSummaryResponse {
	/** The total number of procedures. */
	total: number;
	/** The number of procedures with Ok state. */
	ok: number;
	/** The number of procedures currently running. */
	running: number;
	/** The number of procedures with failed state. */
	failed: number;
	/** The number of procedures with unknown state. */
	unknown: number;
}

/** Get a specific repo. Response: [Repo]. */
export interface GetRepo {
	/** Id or name */
	repo: string;
}

/** List repos matching optional query. Response: [ListReposResponse]. */
export interface ListRepos {
	/** optional structured query to filter repos. */
	query?: RepoQuery;
}

/** Get current action state for the repo. Response: [RepoActionState]. */
export interface GetRepoActionState {
	/** Id or name */
	repo: string;
}

/**
 * Gets a summary of data relating to all repos.
 * Response: [GetReposSummaryResponse].
 */
export interface GetReposSummary {
}

/** Response for [GetReposSummary] */
export interface GetReposSummaryResponse {
	/** The total number of repos */
	total: number;
	/** The number of repos with Ok state. */
	ok: number;
	/** The number of repos currently cloning. */
	cloning: number;
	/** The number of repos currently pulling. */
	pulling: number;
	/** The number of repos with failed state. */
	failed: number;
	/** The number of repos with unknown state. */
	unknown: number;
}

/** Find resources matching a common query. Response: [FindResourcesResponse]. */
export interface FindResources {
	/** The mongo query as JSON */
	query?: MongoDocument;
	/** The resource variants to include in the response. */
	resources?: ResourceTarget["type"][];
}

/** Response for [FindResources]. */
export interface FindResourcesResponse {
	/** The matching servers. */
	servers: ServerListItem[];
	/** The matching deployments. */
	deployments: DeploymentListItem[];
	/** The matching builds. */
	builds: BuildListItem[];
	/** The matching repos. */
	repos: RepoListItem[];
	/** The matching procedures. */
	procedures: ProcedureListItem[];
}

/** Get a specific server. Response: [Server]. */
export interface GetServer {
	/** Id or name */
	server: string;
}

/** List servers matching optional query. Response: [ListServersResponse]. */
export interface ListServers {
	/** optional structured query to filter servers. */
	query?: ServerQuery;
}

/** Get the state of the target server. Response: [GetServerStateResponse]. */
export interface GetServerState {
	/** Id or name */
	server: string;
}

/** The response for [GetServerState]. */
export interface GetServerStateResponse {
	/** The server status. */
	status: ServerState;
}

/** Get current action state for the servers. Response: [ServerActionState]. */
export interface GetServerActionState {
	/** Id or name */
	server: string;
}

/**
 * Get the version of the monitor periphery agent on the target server.
 * Response: [GetPeripheryVersionResponse].
 */
export interface GetPeripheryVersion {
	/** Id or name */
	server: string;
}

/** Response for [GetPeripheryVersion]. */
export interface GetPeripheryVersionResponse {
	/** The version of periphery. */
	version: string;
}

/** Get the docker networks on the server. Response: [GetDockerNetworksResponse]. */
export interface GetDockerNetworks {
	/** Id or name */
	server: string;
}

/**
 * Get the docker images locally cached on the target server.
 * Response: [GetDockerImagesResponse].
 */
export interface GetDockerImages {
	/** Id or name */
	server: string;
}

/**
 * Get all docker containers on the target server.
 * Response: [GetDockerContainersResponse].
 */
export interface GetDockerContainers {
	/** Id or name */
	server: string;
}

/**
 * Get the system information of the target server.
 * Response: [SystemInformation].
 */
export interface GetSystemInformation {
	/** Id or name */
	server: string;
}

/**
 * Get the system stats on the target server. Response: [SystemStats].
 * 
 * Note. This does not hit the server directly. The stats come from an
 * in memory cache on the core, which hits the server periodically
 * to keep it up to date.
 */
export interface GetSystemStats {
	/** Id or name */
	server: string;
}

/**
 * Get the processes running on the target server.
 * Response: [GetSystemProcessesResponse].
 * 
 * Note. This does not hit the server directly. The procedures come from an
 * in memory cache on the core, which hits the server periodically
 * to keep it up to date.
 */
export interface GetSystemProcesses {
	/** Id or name */
	server: string;
}

/**
 * Paginated endpoint serving historical (timeseries) server stats for graphing.
 * Response: [GetHistoricalServerStatsResponse].
 */
export interface GetHistoricalServerStats {
	/** Id or name */
	server: string;
	/** The granularity of the data. */
	granularity: Timelength;
	/**
	 * Page of historical data. Default is 0, which is the most recent data.
	 * Use with the `next_page` field of the response.
	 */
	page?: number;
}

/** System stats stored on the database. */
export interface SystemStatsRecord {
	/** Unix timestamp in milliseconds */
	ts: I64;
	/** Server id */
	sid: string;
	/** Cpu usage percentage */
	cpu_perc: number;
	/** Memory used in GB */
	mem_used_gb: number;
	/** Total memory in GB */
	mem_total_gb: number;
	/** Disk used in GB */
	disk_used_gb: number;
	/** Total disk size in GB */
	disk_total_gb: number;
	/** Breakdown of individual disks, ie their usages, sizes, and mount points */
	disks: SingleDiskUsage[];
}

/** Response to [GetHistoricalServerStats]. */
export interface GetHistoricalServerStatsResponse {
	/** The timeseries page of data. */
	stats: SystemStatsRecord[];
	/** If there is a next page of data, pass this to `page` to get it. */
	next_page?: number;
}

/**
 * Gets a summary of data relating to all servers.
 * Response: [GetServersSummaryResponse].
 */
export interface GetServersSummary {
}

/** Response for [GetServersSummary]. */
export interface GetServersSummaryResponse {
	/** The total number of servers. */
	total: I64;
	/** The number of healthy (`status: OK`) servers. */
	healthy: I64;
	/** The number of unhealthy servers. */
	unhealthy: I64;
	/** The number of disabled servers. */
	disabled: I64;
}

/**
 * Get the usernames for the available github / docker accounts
 * on the target server.
 * Response: [GetAvailableAccountsResponse].
 */
export interface GetAvailableAccounts {
	/** Id or name */
	server: string;
}

/** Response for [GetAvailableAccounts]. */
export interface GetAvailableAccountsResponse {
	/** The github usernames */
	github: string[];
	/** The docker usernames. */
	docker: string[];
}

/**
 * Get the keys for available secrets on the target server.
 * Response: [GetAvailableSecretsResponse].
 */
export interface GetAvailableSecrets {
	/** Id or name */
	server: string;
}

/** Get a specific server template by id or name. Response: [ServerTemplate]. */
export interface GetServerTemplate {
	/** Id or name */
	server_template: string;
}

/** List server templates matching structured query. Response: [ListServerTemplatesResponse]. */
export interface ListServerTemplates {
	query?: ServerTemplateQuery;
}

/**
 * Gets a summary of data relating to all server templates.
 * Response: [GetServerTemplatesSummaryResponse].
 */
export interface GetServerTemplatesSummary {
}

/** Response for [GetServerTemplatesSummary]. */
export interface GetServerTemplatesSummaryResponse {
	/** The total number of server templates. */
	total: number;
}

/** Get data for a specific tag. Response [Tag]. */
export interface GetTag {
	/** Id or name */
	tag: string;
}

/**
 * List data for tags matching optional mongo query.
 * Response: [ListTagsResponse].
 */
export interface ListTags {
	query?: MongoDocument;
}

/**
 * Get pretty formatted monrun sync toml for all resources
 * which the user has permissions to view.
 * Response: [TomlResponse].
 */
export interface ExportAllResourcesToToml {
}

/**
 * Get pretty formatted monrun sync toml for specific resources and user groups.
 * Response: [TomlResponse].
 */
export interface ExportResourcesToToml {
	/** The targets to include in the export. */
	targets: ResourceTarget[];
	/** The user group names or ids to include in the export. */
	user_groups: string[];
}

/**
 * Get all data for the target update.
 * Response: [Update].
 */
export interface GetUpdate {
	/** The update id. */
	id: string;
}

/**
 * Paginated endpoint for updates matching optional query.
 * More recent updates will be returned first.
 */
export interface ListUpdates {
	/** An optional mongo query to filter the updates. */
	query?: MongoDocument;
	/**
	 * Page of updates. Default is 0, which is the most recent data.
	 * Use with the `next_page` field of the response.
	 */
	page?: number;
}

export interface UpdateListItem {
	id: string;
	operation: Operation;
	start_ts: I64;
	success: boolean;
	username: string;
	operator: string;
	target: ResourceTarget;
	status: UpdateStatus;
	version: Version;
}

/** Response for [ListUpdates]. */
export interface ListUpdatesResponse {
	/** The page of updates, sorted by timestamp descending. */
	updates: UpdateListItem[];
	/** If there is a next page of data, pass this to `page` to get it. */
	next_page?: number;
}

/**
 * Gets list of api keys for the calling user.
 * Response: [ListApiKeysResponse]
 */
export interface ListApiKeys {
}

/**
 * Gets list of api keys for the user at ID.
 * **Admin only.**
 * Will still fail if you call for a user_id that isn't a service user.
 * Response: [ListApiKeysForServiceUserResponse]
 */
export interface ListApiKeysForServiceUser {
	/** The id of the user. */
	user_id: string;
}

/**
 * Gets list of monitor users.
 * **Admin only.**
 * Response: [ListUsersResponse]
 */
export interface ListUsers {
}

/**
 * Gets the username of a specific user.
 * Response: [GetUsernameResponse]
 */
export interface GetUsername {
	/** The id of the user. */
	user_id: string;
}

/** Response for [GetUsername]. */
export interface GetUsernameResponse {
	/** The username of the user. */
	username: string;
	/** An optional icon for the user. */
	avatar?: string;
}

/**
 * Get a specific user group by name or id.
 * Response: [UserGroup].
 */
export interface GetUserGroup {
	/** Name or Id */
	user_group: string;
}

/**
 * List all user groups which user can see. Response: [ListUserGroupsResponse].
 * 
 * Admins can see all user groups,
 * and users can see user groups to which they belong.
 */
export interface ListUserGroups {
}

/**
 * List all available global variables.
 * Response: [Variable]
 */
export interface GetVariable {
	/** The name of the variable to get. */
	name: string;
}

/**
 * List all available global variables.
 * Response: [ListVariablesResponse]
 */
export interface ListVariables {
}

/** The response of [ListVariables]. */
export interface ListVariablesResponse {
	/** The available global variables. */
	variables: Variable[];
	/** The available global secret keys */
	secrets: string[];
}

export type PartialAlerterConfig = 
	| { type: "Custom", params: _PartialCustomAlerterConfig }
	| { type: "Slack", params: _PartialSlackAlerterConfig };

/** Create an alerter. Response: [Alerter]. */
export interface CreateAlerter {
	/** The name given to newly created alerter. */
	name: string;
	/** Optional partial config to initialize the alerter with. */
	config: PartialAlerterConfig;
}

/**
 * Creates a new alerter with given `name` and the configuration
 * of the alerter at the given `id`. Response: [Alerter].
 */
export interface CopyAlerter {
	/** The name of the new alerter. */
	name: string;
	/** The id of the alerter to copy. */
	id: string;
}

/**
 * Deletes the alerter at the given id, and returns the deleted alerter.
 * Response: [Alerter]
 */
export interface DeleteAlerter {
	/** The id of the alerter to delete. */
	id: string;
}

/**
 * Update the alerter at the given id, and return the updated alerter. Response: [Alerter].
 * 
 * Note. This method updates only the fields which are set in the [PartialAlerterConfig],
 * effectively merging diffs into the final document. This is helpful when multiple users are using
 * the same resources concurrently by ensuring no unintentional
 * field changes occur from out of date local state.
 */
export interface UpdateAlerter {
	/** The id of the alerter to update. */
	id: string;
	/** The partial config update to apply. */
	config: PartialAlerterConfig;
}

/**
 * Create an api key for the calling user.
 * Response: [CreateApiKeyResponse].
 * 
 * Note. After the response is served, there will be no way
 * to get the secret later.
 */
export interface CreateApiKey {
	/** The name for the api key. */
	name: string;
	/**
	 * A unix timestamp in millseconds specifying api key expire time.
	 * Default is 0, which means no expiry.
	 */
	expires?: I64;
}

/**
 * Delete an api key for the calling user.
 * Response: [NoData]
 */
export interface DeleteApiKey {
	/** The key which the user intends to delete. */
	key: string;
}

/**
 * Admin only method to create an api key for a service user.
 * Response: [CreateApiKeyResponse].
 */
export interface CreateApiKeyForServiceUser {
	/** Must be service user */
	user_id: string;
	/** The name for the api key */
	name: string;
	/**
	 * A unix timestamp in millseconds specifying api key expire time.
	 * Default is 0, which means no expiry.
	 */
	expires?: I64;
}

/**
 * Admin only method to delete an api key for a service user.
 * Response: [NoData].
 */
export interface DeleteApiKeyForServiceUser {
	key: string;
}

/** Create a build. Response: [Build]. */
export interface CreateBuild {
	/** The name given to newly created build. */
	name: string;
	/** Optional partial config to initialize the build with. */
	config: _PartialBuildConfig;
}

/**
 * Creates a new build with given `name` and the configuration
 * of the build at the given `id`. Response: [Build].
 */
export interface CopyBuild {
	/** The name of the new build. */
	name: string;
	/** The id of the build to copy. */
	id: string;
}

/**
 * Deletes the build at the given id, and returns the deleted build.
 * Response: [Build]
 */
export interface DeleteBuild {
	/** The id of the build to delete. */
	id: string;
}

/**
 * Update the build at the given id, and return the updated build.
 * Response: [Build].
 * 
 * Note. This method updates only the fields which are set in the [_PartialBuildConfig],
 * effectively merging diffs into the final document.
 * This is helpful when multiple users are using
 * the same resources concurrently by ensuring no unintentional
 * field changes occur from out of date local state.
 */
export interface UpdateBuild {
	/** The id of the build to update. */
	id: string;
	/** The partial config update to apply. */
	config: _PartialBuildConfig;
}

/** Partial representation of [BuilderConfig] */
export type PartialBuilderConfig = 
	| { type: "Server", params: _PartialServerBuilderConfig }
	| { type: "Aws", params: _PartialAwsBuilderConfig };

/** Create a builder. Response: [Builder]. */
export interface CreateBuilder {
	/** The name given to newly created builder. */
	name: string;
	/** Optional partial config to initialize the builder with. */
	config: PartialBuilderConfig;
}

/**
 * Creates a new builder with given `name` and the configuration
 * of the builder at the given `id`. Response: [Builder]
 */
export interface CopyBuilder {
	/** The name of the new builder. */
	name: string;
	/** The id of the builder to copy. */
	id: string;
}

/**
 * Deletes the builder at the given id, and returns the deleted builder.
 * Response: [Builder]
 */
export interface DeleteBuilder {
	/** The id of the builder to delete. */
	id: string;
}

/**
 * Update the builder at the given id, and return the updated builder.
 * Response: [Builder].
 * 
 * Note. This method updates only the fields which are set in the [PartialBuilderConfig],
 * effectively merging diffs into the final document.
 * This is helpful when multiple users are using
 * the same resources concurrently by ensuring no unintentional
 * field changes occur from out of date local state.
 */
export interface UpdateBuilder {
	/** The id of the builder to update. */
	id: string;
	/** The partial config update to apply. */
	config: PartialBuilderConfig;
}

/** Create a deployment. Response: [Deployment]. */
export interface CreateDeployment {
	/** The name given to newly created deployment. */
	name: string;
	/** Optional partial config to initialize the deployment with. */
	config: _PartialDeploymentConfig;
}

/**
 * Creates a new deployment with given `name` and the configuration
 * of the deployment at the given `id`. Response: [Deployment]
 */
export interface CopyDeployment {
	/** The name of the new deployment. */
	name: string;
	/** The id of the deployment to copy. */
	id: string;
}

/**
 * Deletes the deployment at the given id, and returns the deleted deployment.
 * Response: [Deployment].
 */
export interface DeleteDeployment {
	/** The id of the deployment to delete. */
	id: string;
}

/**
 * Update the deployment at the given id, and return the updated deployment.
 * Response: [Deployment].
 * 
 * Note. This method updates only the fields which are set in the [_PartialDeploymentConfig],
 * effectively merging diffs into the final document.
 * This is helpful when multiple users are using
 * the same resources concurrently by ensuring no unintentional
 * field changes occur from out of date local state.
 */
export interface UpdateDeployment {
	/** The deployment id to update. */
	id: string;
	/** The partial config update. */
	config: _PartialDeploymentConfig;
}

/**
 * Rename the deployment at id to the given name. Response: [Update].
 * 
 * Note. If a container is created for the deployment, it will be renamed using
 * `docker rename ...`.
 */
export interface RenameDeployment {
	/** The id of the deployment to rename. */
	id: string;
	/** The new name. */
	name: string;
}

/**
 * Update a resources description.
 * Response: [NoData].
 */
export interface UpdateDescription {
	/** The target resource to set description for. */
	target: ResourceTarget;
	/** The new description. */
	description: string;
}

/**
 * Update a user or user groups permission on a resource.
 * Response: [NoData].
 */
export interface UpdatePermissionOnTarget {
	/** Specify the user or user group. */
	user_target: UserTarget;
	/** Specify the target resource. */
	resource_target: ResourceTarget;
	/** Specify the permission level. */
	permission: PermissionLevel;
}

/**
 * Update a user's "base" permissions, eg. "enabled".
 * Response: [NoData].
 */
export interface UpdateUserBasePermissions {
	/** The target user. */
	user_id: string;
	/** If specified, will update users enabled state. */
	enabled?: boolean;
	/** If specified, will update user's ability to create servers. */
	create_servers?: boolean;
	/** If specified, will update user's ability to create builds. */
	create_builds?: boolean;
}

/** Create a procedure. Response: [Procedure]. */
export interface CreateProcedure {
	/** The name given to newly created build. */
	name: string;
	/** Optional partial config to initialize the procedure with. */
	config: _PartialProcedureConfig;
}

/**
 * Creates a new procedure with given `name` and the configuration
 * of the procedure at the given `id`. Response: [Procedure].
 */
export interface CopyProcedure {
	/** The name of the new procedure. */
	name: string;
	/** The id of the procedure to copy. */
	id: string;
}

/**
 * Deletes the procedure at the given id, and returns the deleted procedure.
 * Response: [Procedure]
 */
export interface DeleteProcedure {
	/** The id of the procedure to delete. */
	id: string;
}

/**
 * Update the procedure at the given id, and return the updated procedure.
 * Response: [Procedure].
 * 
 * Note. This method updates only the fields which are set in the [_PartialProcedureConfig],
 * effectively merging diffs into the final document.
 * This is helpful when multiple users are using
 * the same resources concurrently by ensuring no unintentional
 * field changes occur from out of date local state.
 */
export interface UpdateProcedure {
	/** The id of the procedure to update. */
	id: string;
	/** The partial config update. */
	config: _PartialProcedureConfig;
}

/** Create a repo. Response: [Repo]. */
export interface CreateRepo {
	/** The name given to newly created repo. */
	name: string;
	/** Optional partial config to initialize the repo with. */
	config: _PartialRepoConfig;
}

/**
 * Creates a new repo with given `name` and the configuration
 * of the repo at the given `id`. Response: [Repo].
 */
export interface CopyRepo {
	/** The name of the new repo. */
	name: string;
	/** The id of the repo to copy. */
	id: string;
}

/**
 * Deletes the repo at the given id, and returns the deleted repo.
 * Response: [Repo]
 */
export interface DeleteRepo {
	/** The id of the repo to delete. */
	id: string;
}

/**
 * Update the repo at the given id, and return the updated repo.
 * Response: [Repo].
 * 
 * Note. If the attached server for the repo changes,
 * the repo will be deleted / cleaned up on the old server.
 * 
 * Note. This method updates only the fields which are set in the [_PartialRepoConfig],
 * effectively merging diffs into the final document.
 * This is helpful when multiple users are using
 * the same resources concurrently by ensuring no unintentional
 * field changes occur from out of date local state.
 */
export interface UpdateRepo {
	/** The id of the repo to update. */
	id: string;
	/** The partial config update to apply. */
	config: _PartialRepoConfig;
}

/** Create a server. Response: [Server]. */
export interface CreateServer {
	/** The name given to newly created server. */
	name: string;
	/** Optional partial config to initialize the server with. */
	config: _PartialServerConfig;
}

/**
 * Deletes the server at the given id, and returns the deleted server.
 * Response: [Server]
 */
export interface DeleteServer {
	/** The id of the server to delete. */
	id: string;
}

/**
 * Update the server at the given id, and return the updated server.
 * Response: [Server].
 * 
 * Note. This method updates only the fields which are set in the [_PartialServerConfig],
 * effectively merging diffs into the final document.
 * This is helpful when multiple users are using
 * the same resources concurrently by ensuring no unintentional
 * field changes occur from out of date local state.
 */
export interface UpdateServer {
	/** The id of the server to update. */
	id: string;
	/** The partial config update to apply. */
	config: _PartialServerConfig;
}

/** Rename the server at id to the given name. Response: [Update]. */
export interface RenameServer {
	/** The id of the server to rename. */
	id: string;
	/** The new name. */
	name: string;
}

/**
 * Create a docker network on the server.
 * Respone: [Update]
 */
export interface CreateNetwork {
	/** Id or name */
	server: string;
	/** The name of the network to create. */
	name: string;
}

/**
 * Delete a docker network.
 * Response: [Update]
 */
export interface DeleteNetwork {
	/** Id or name. */
	server: string;
	/** The name of the network to delete. */
	name: string;
}

export type PartialServerTemplateConfig = 
	| { type: "Aws", params: _PartialAwsServerTemplateConfig }
	| { type: "Hetzner", params: _PartialHetznerServerTemplateConfig };

/** Create a server template. Response: [ServerTemplate]. */
export interface CreateServerTemplate {
	/** The name given to newly created server template. */
	name: string;
	/** Optional partial config to initialize the server template with. */
	config: PartialServerTemplateConfig;
}

/**
 * Creates a new server template with given `name` and the configuration
 * of the server template at the given `id`. Response: [ServerTemplate]
 */
export interface CopyServerTemplate {
	/** The name of the new server template. */
	name: string;
	/** The id of the server template to copy. */
	id: string;
}

/**
 * Deletes the server template at the given id, and returns the deleted server template.
 * Response: [ServerTemplate]
 */
export interface DeleteServerTemplate {
	/** The id of the server template to delete. */
	id: string;
}

/**
 * Update the server template at the given id, and return the updated server template.
 * Response: [ServerTemplate].
 * 
 * Note. This method updates only the fields which are set in the [PartialServerTemplateConfig],
 * effectively merging diffs into the final document.
 * This is helpful when multiple users are using
 * the same resources concurrently by ensuring no unintentional
 * field changes occur from out of date local state.
 */
export interface UpdateServerTemplate {
	/** The id of the server template to update. */
	id: string;
	/** The partial config update to apply. */
	config: PartialServerTemplateConfig;
}

/** Create a tag. Response: [Tag]. */
export interface CreateTag {
	/** The name of the tag. */
	name: string;
}

/**
 * Delete a tag, and return the deleted tag. Response: [Tag].
 * 
 * Note. Will also remove this tag from all attached resources.
 */
export interface DeleteTag {
	/** The id of the tag to delete. */
	id: string;
}

/** Rename a tag at id. Response: [Tag]. */
export interface RenameTag {
	/** The id of the tag to rename. */
	id: string;
	/** The new name of the tag. */
	name: string;
}

/**
 * Update the tags on a resource.
 * Response: [NoData]
 */
export interface UpdateTagsOnResource {
	target: ResourceTarget;
	/** Tag Ids */
	tags: string[];
}

/**
 * Push a resource to the front of the users 10 most recently viewed resources.
 * Response: [NoData].
 */
export interface PushRecentlyViewed {
	/** The target to push. */
	resource: ResourceTarget;
}

/**
 * Set the time the user last opened the UI updates.
 * Used for unseen notification dot.
 * Response: [NoData]
 */
export interface SetLastSeenUpdate {
}

/**
 * **Admin only.** Create a service user.
 * Response: [User].
 */
export interface CreateServiceUser {
	/** The username for the service user. */
	username: string;
	/** A description for the service user. */
	description: string;
}

/**
 * **Admin only.** Update a service user's description.
 * Response: [User].
 */
export interface UpdateServiceUserDescription {
	/** The service user's username */
	username: string;
	/** A new description for the service user. */
	description: string;
}

/** **Admin only.** Create a user group. Response: [UserGroup] */
export interface CreateUserGroup {
	/** The name to assign to the new UserGroup */
	name: string;
}

/** **Admin only.** Rename a user group. Response: [UserGroup] */
export interface RenameUserGroup {
	/** The id of the UserGroup */
	id: string;
	/** The new name for the UserGroup */
	name: string;
}

/** **Admin only.** Delete a user group. Response: [UserGroup] */
export interface DeleteUserGroup {
	/** The id of the UserGroup */
	id: string;
}

/** **Admin only.** Add a user to a user group. Response: [UserGroup] */
export interface AddUserToUserGroup {
	/** The name or id of UserGroup that user should be added to. */
	user_group: string;
	/** The id or username of the user to add */
	user: string;
}

/** **Admin only.** Remove a user from a user group. Response: [UserGroup] */
export interface RemoveUserFromUserGroup {
	/** The name or id of UserGroup that user should be removed from. */
	user_group: string;
	/** The id or username of the user to remove */
	user: string;
}

/**
 * **Admin only.** Completely override the user in the group.
 * Response: [UserGroup]
 */
export interface SetUsersInUserGroup {
	/** Id or name. */
	user_group: string;
	/** The user ids or usernames to hard set as the group's users. */
	users: string[];
}

/** **Admin only.** Create variable. Response: [Variable]. */
export interface CreateVariable {
	/** The name of the variable to create. */
	name: string;
	/** The initial value of the variable. defualt: "". */
	value?: string;
	/** The initial value of the description. default: "". */
	description?: string;
}

/** **Admin only.** Update variable. Response: [Variable]. */
export interface UpdateVariableValue {
	/** The name of the variable to update. */
	name: string;
	/** The value to set. */
	value: string;
}

/** **Admin only.** Update variable. Response: [Variable]. */
export interface UpdateVariableDescription {
	/** The name of the variable to update. */
	name: string;
	/** The description to set. */
	description: string;
}

/** **Admin only.** Delete a variable. Response: [Variable]. */
export interface DeleteVariable {
	name: string;
}

/** Configuration for a custom alerter. */
export interface CustomAlerterConfig {
	/** The http/s endpoint to send the POST to */
	url: string;
	/** Whether the alerter is enabled */
	enabled?: boolean;
}

/** Configuration for a slack alerter. */
export interface SlackAlerterConfig {
	/** The slack app url */
	url: string;
	/** Whether the alerter is enabled */
	enabled?: boolean;
}

/** Configuration for a monitor server builder. */
export interface ServerBuilderConfig {
	/** The server id of the builder */
	server_id: string;
}

/** Configuration for an AWS builder. */
export interface AwsBuilderConfig {
	/** The AWS region to create the instance in */
	region: string;
	/** The instance type to create for the build */
	instance_type: string;
	/** The size of the builder volume in gb */
	volume_gb: number;
	/**
	 * The port periphery will be running on.
	 * Default: `8120`
	 */
	port: number;
	/**
	 * The EC2 ami id to create.
	 * The ami should have the periphery client configured to start on startup,
	 * and should have the necessary github / dockerhub accounts configured.
	 */
	ami_id: string;
	/** The subnet id to create the instance in. */
	subnet_id: string;
	/**
	 * The security group ids to attach to the instance.
	 * This should include a security group to allow core inbound access to the periphery port.
	 */
	security_group_ids: string[];
	/** The key pair name to attach to the instance */
	key_pair_name: string;
	/**
	 * Whether to assign the instance a public IP address.
	 * Likely needed for the instance to be able to reach the open internet.
	 */
	assign_public_ip: boolean;
	/**
	 * Whether core should use the public IP address to communicate with periphery on the builder.
	 * If false, core will communicate with the instance using the private IP.
	 */
	use_public_ip: boolean;
	/** Which github accounts (usernames) are available on the AMI */
	github_accounts?: string[];
	/** Which dockerhub accounts (usernames) are available on the AMI */
	docker_accounts?: string[];
}

export interface CloneArgs {
	name: string;
	repo?: string;
	branch?: string;
	commit?: string;
	on_clone?: SystemCommand;
	on_pull?: SystemCommand;
	github_account?: string;
}

/** Info for the all system disks combined. */
export interface TotalDiskUsage {
	/** Used portion in GB */
	used_gb: number;
	/** Total size in GB */
	total_gb: number;
}

/** Summary of the health of the server. */
export interface ServerHealth {
	cpu: SeverityLevel;
	mem: SeverityLevel;
	disks: Record<string, SeverityLevel>;
}

export enum AwsVolumeType {
	Gp2 = "gp2",
	Gp3 = "gp3",
	Io1 = "io1",
	Io2 = "io2",
}

/**
 * For information on AWS volumes, see
 * `<https://docs.aws.amazon.com/ebs/latest/userguide/ebs-volume-types.html>`.
 */
export interface AwsVolume {
	/** The device name (for example, `/dev/sda1` or `xvdh`). */
	device_name: string;
	/** The size of the volume in GB */
	size_gb: number;
	/** The type of volume. Options: gp2, gp3, io1, io2. */
	volume_type: AwsVolumeType;
	/** The iops of the volume, or 0 for AWS default. */
	iops: number;
	/** The throughput of the volume, or 0 for AWS default. */
	throughput: number;
}

/** Aws EC2 instance config. */
export interface AwsServerTemplateConfig {
	/** The aws region to launch the server in, eg. us-east-1 */
	region: string;
	/** The instance type to launch, eg. c5.2xlarge */
	instance_type: string;
	/** Specify the ami id to use. Must be set up to start the periphery binary on startup. */
	ami_id: string;
	/** The subnet to assign to the instance. */
	subnet_id: string;
	/** The key pair name to give to the instance in case SSH access required. */
	key_pair_name: string;
	/**
	 * Assign a public ip to the instance. Depending on how your network is
	 * setup, this may be required for the instance to reach the public internet.
	 */
	assign_public_ip: boolean;
	/**
	 * Use the instances public ip as the address for the server.
	 * Could be used when build instances are created in another non-interconnected network to the core api.
	 */
	use_public_ip: boolean;
	/**
	 * The port periphery will be running on in AMI.
	 * Default: `8120`
	 */
	port: number;
	/** The user data to deploy the instance with. */
	user_data?: string;
	/** The security groups to give to the instance. */
	security_group_ids?: string[];
	/** Specify the EBS volumes to attach. */
	volumes: AwsVolume[];
}

export enum HetznerDatacenter {
	Nuremberg1Dc3 = "Nuremberg1Dc3",
	Helsinki1Dc2 = "Helsinki1Dc2",
	Falkenstein1Dc14 = "Falkenstein1Dc14",
	AshburnDc1 = "AshburnDc1",
	HillsboroDc1 = "HillsboroDc1",
}

export enum HetznerServerType {
	SharedIntel1Core2Ram20Disk = "SharedIntel1Core2Ram20Disk",
	SharedAmd2Core2Ram40Disk = "SharedAmd2Core2Ram40Disk",
	SharedArm2Core4Ram40Disk = "SharedArm2Core4Ram40Disk",
	SharedIntel2Core4Ram40Disk = "SharedIntel2Core4Ram40Disk",
	SharedAmd3Core4Ram80Disk = "SharedAmd3Core4Ram80Disk",
	SharedArm4Core8Ram80Disk = "SharedArm4Core8Ram80Disk",
	SharedIntel2Core8Ram80Disk = "SharedIntel2Core8Ram80Disk",
	SharedAmd4Core8Ram160Disk = "SharedAmd4Core8Ram160Disk",
	SharedArm8Core16Ram160Disk = "SharedArm8Core16Ram160Disk",
	SharedIntel4Core16Ram160Disk = "SharedIntel4Core16Ram160Disk",
	SharedAmd8Core16Ram240Disk = "SharedAmd8Core16Ram240Disk",
	SharedArm16Core32Ram320Disk = "SharedArm16Core32Ram320Disk",
	SharedIntel8Core32Ram240Disk = "SharedIntel8Core32Ram240Disk",
	SharedAmd16Core32Ram360Disk = "SharedAmd16Core32Ram360Disk",
	DedicatedAmd2Core8Ram80Disk = "DedicatedAmd2Core8Ram80Disk",
	DedicatedAmd4Core16Ram160Disk = "DedicatedAmd4Core16Ram160Disk",
	DedicatedAmd8Core32Ram240Disk = "DedicatedAmd8Core32Ram240Disk",
	DedicatedAmd16Core64Ram360Disk = "DedicatedAmd16Core64Ram360Disk",
	DedicatedAmd32Core128Ram600Disk = "DedicatedAmd32Core128Ram600Disk",
	DedicatedAmd48Core192Ram960Disk = "DedicatedAmd48Core192Ram960Disk",
}

export enum HetznerVolumeFormat {
	Xfs = "Xfs",
	Ext4 = "Ext4",
}

export interface HetznerVolumeSpecs {
	/** A name for the volume */
	name: string;
	/** The format for the volume */
	format: HetznerVolumeFormat;
	/** Labels for the volume */
	labels: Record<string, string>;
	/** Size of the volume in GB */
	size_gb: I64;
}

/** Hetzner server config. */
export interface HetznerServerTemplateConfig {
	/** ID or name of the Image the Server is created from */
	image?: string;
	/** Auto-mount Volumes after attach */
	automount: boolean;
	/** ID or name of Datacenter to create Server in */
	datacenter?: HetznerDatacenter;
	/** Network IDs which should be attached to the Server private network interface at the creation time */
	private_network_ids?: I64[];
	/**
	 * ID of the Placement Group the server should be in,
	 * Or 0 to not use placement group.
	 */
	placement_group?: I64;
	/** Attach an IPv4 on the public NIC. If false, no IPv4 address will be attached. */
	enable_public_ipv4?: boolean;
	/** Attach an IPv6 on the public NIC. If false, no IPv6 address will be attached. */
	enable_public_ipv6?: boolean;
	/** The firewalls to attach to the instance */
	firewall_ids?: I64[];
	/** ID or name of the Server type this Server should be created with */
	server_type?: HetznerServerType;
	/** SSH key IDs ( integer ) or names ( string ) which should be injected into the Server at creation time */
	ssh_keys?: string[];
	/** Cloud-Init user data to use during Server creation. This field is limited to 32KiB. */
	user_data?: string;
	/** Connect to the instance using it's public ip. */
	use_public_ip?: boolean;
	/** Labels for the server */
	labels?: Record<string, string>;
	/** Specs for volumes to attach */
	volumes?: HetznerVolumeSpecs[];
	/**
	 * The port periphery will be running on in AMI.
	 * Default: `8120`
	 */
	port: number;
}

export type AuthRequest = 
	| { type: "GetLoginOptions", params: GetLoginOptions }
	| { type: "CreateLocalUser", params: CreateLocalUser }
	| { type: "LoginLocalUser", params: LoginLocalUser }
	| { type: "ExchangeForJwt", params: ExchangeForJwt }
	| { type: "GetUser", params: GetUser };

export type ExecuteRequest = 
	| { type: "PruneContainers", params: PruneDockerContainers }
	| { type: "PruneImages", params: PruneDockerImages }
	| { type: "PruneNetworks", params: PruneDockerNetworks }
	| { type: "Deploy", params: Deploy }
	| { type: "StartContainer", params: StartContainer }
	| { type: "StopContainer", params: StopContainer }
	| { type: "StopAllContainers", params: StopAllContainers }
	| { type: "RemoveContainer", params: RemoveContainer }
	| { type: "RunBuild", params: RunBuild }
	| { type: "CancelBuild", params: CancelBuild }
	| { type: "CloneRepo", params: CloneRepo }
	| { type: "PullRepo", params: PullRepo }
	| { type: "RunProcedure", params: RunProcedure }
	| { type: "LaunchServer", params: LaunchServer };

export type ReadRequest = 
	| { type: "GetVersion", params: GetVersion }
	| { type: "GetCoreInfo", params: GetCoreInfo }
	| { type: "ListUsers", params: ListUsers }
	| { type: "GetUsername", params: GetUsername }
	| { type: "ListApiKeys", params: ListApiKeys }
	| { type: "ListApiKeysForServiceUser", params: ListApiKeysForServiceUser }
	| { type: "ListPermissions", params: ListPermissions }
	| { type: "GetPermissionLevel", params: GetPermissionLevel }
	| { type: "ListUserTargetPermissions", params: ListUserTargetPermissions }
	| { type: "GetUserGroup", params: GetUserGroup }
	| { type: "ListUserGroups", params: ListUserGroups }
	| { type: "FindResources", params: FindResources }
	| { type: "GetProceduresSummary", params: GetProceduresSummary }
	| { type: "GetProcedure", params: GetProcedure }
	| { type: "GetProcedureActionState", params: GetProcedureActionState }
	| { type: "ListProcedures", params: ListProcedures }
	| { type: "GetServerTemplate", params: GetServerTemplate }
	| { type: "ListServerTemplates", params: ListServerTemplates }
	| { type: "GetServerTemplatesSummary", params: GetServerTemplatesSummary }
	| { type: "GetServersSummary", params: GetServersSummary }
	| { type: "GetServer", params: GetServer }
	| { type: "ListServers", params: ListServers }
	| { type: "GetServerState", params: GetServerState }
	| { type: "GetPeripheryVersion", params: GetPeripheryVersion }
	| { type: "GetDockerContainers", params: GetDockerContainers }
	| { type: "GetDockerImages", params: GetDockerImages }
	| { type: "GetDockerNetworks", params: GetDockerNetworks }
	| { type: "GetServerActionState", params: GetServerActionState }
	| { type: "GetHistoricalServerStats", params: GetHistoricalServerStats }
	| { type: "GetAvailableAccounts", params: GetAvailableAccounts }
	| { type: "GetAvailableSecrets", params: GetAvailableSecrets }
	| { type: "GetDeploymentsSummary", params: GetDeploymentsSummary }
	| { type: "GetDeployment", params: GetDeployment }
	| { type: "ListDeployments", params: ListDeployments }
	| { type: "GetDeploymentContainer", params: GetDeploymentContainer }
	| { type: "GetDeploymentActionState", params: GetDeploymentActionState }
	| { type: "GetDeploymentStats", params: GetDeploymentStats }
	| { type: "GetLog", params: GetLog }
	| { type: "SearchLog", params: SearchLog }
	| { type: "ListCommonDeploymentExtraArgs", params: ListCommonDeploymentExtraArgs }
	| { type: "GetBuildsSummary", params: GetBuildsSummary }
	| { type: "GetBuild", params: GetBuild }
	| { type: "ListBuilds", params: ListBuilds }
	| { type: "GetBuildActionState", params: GetBuildActionState }
	| { type: "GetBuildMonthlyStats", params: GetBuildMonthlyStats }
	| { type: "GetBuildVersions", params: GetBuildVersions }
	| { type: "ListCommonBuildExtraArgs", params: ListCommonBuildExtraArgs }
	| { type: "ListDockerOrganizations", params: ListDockerOrganizations }
	| { type: "GetReposSummary", params: GetReposSummary }
	| { type: "GetRepo", params: GetRepo }
	| { type: "ListRepos", params: ListRepos }
	| { type: "GetRepoActionState", params: GetRepoActionState }
	| { type: "GetBuildersSummary", params: GetBuildersSummary }
	| { type: "GetBuilder", params: GetBuilder }
	| { type: "ListBuilders", params: ListBuilders }
	| { type: "GetBuilderAvailableAccounts", params: GetBuilderAvailableAccounts }
	| { type: "GetAlertersSummary", params: GetAlertersSummary }
	| { type: "GetAlerter", params: GetAlerter }
	| { type: "ListAlerters", params: ListAlerters }
	| { type: "ExportAllResourcesToToml", params: ExportAllResourcesToToml }
	| { type: "ExportResourcesToToml", params: ExportResourcesToToml }
	| { type: "GetTag", params: GetTag }
	| { type: "ListTags", params: ListTags }
	| { type: "GetUpdate", params: GetUpdate }
	| { type: "ListUpdates", params: ListUpdates }
	| { type: "ListAlerts", params: ListAlerts }
	| { type: "GetAlert", params: GetAlert }
	| { type: "GetSystemInformation", params: GetSystemInformation }
	| { type: "GetSystemStats", params: GetSystemStats }
	| { type: "GetSystemProcesses", params: GetSystemProcesses }
	| { type: "GetVariable", params: GetVariable }
	| { type: "ListVariables", params: ListVariables };

export type WriteRequest = 
	| { type: "CreateApiKey", params: CreateApiKey }
	| { type: "DeleteApiKey", params: DeleteApiKey }
	| { type: "CreateApiKeyForServiceUser", params: CreateApiKeyForServiceUser }
	| { type: "DeleteApiKeyForServiceUser", params: DeleteApiKeyForServiceUser }
	| { type: "PushRecentlyViewed", params: PushRecentlyViewed }
	| { type: "SetLastSeenUpdate", params: SetLastSeenUpdate }
	| { type: "CreateServiceUser", params: CreateServiceUser }
	| { type: "UpdateServiceUserDescription", params: UpdateServiceUserDescription }
	| { type: "CreateUserGroup", params: CreateUserGroup }
	| { type: "RenameUserGroup", params: RenameUserGroup }
	| { type: "DeleteUserGroup", params: DeleteUserGroup }
	| { type: "AddUserToUserGroup", params: AddUserToUserGroup }
	| { type: "RemoveUserFromUserGroup", params: RemoveUserFromUserGroup }
	| { type: "SetUsersInUserGroup", params: SetUsersInUserGroup }
	| { type: "UpdateUserBasePermissions", params: UpdateUserBasePermissions }
	| { type: "UpdatePermissionOnTarget", params: UpdatePermissionOnTarget }
	| { type: "UpdateDescription", params: UpdateDescription }
	| { type: "CreateServer", params: CreateServer }
	| { type: "DeleteServer", params: DeleteServer }
	| { type: "UpdateServer", params: UpdateServer }
	| { type: "RenameServer", params: RenameServer }
	| { type: "CreateNetwork", params: CreateNetwork }
	| { type: "DeleteNetwork", params: DeleteNetwork }
	| { type: "CreateDeployment", params: CreateDeployment }
	| { type: "CopyDeployment", params: CopyDeployment }
	| { type: "DeleteDeployment", params: DeleteDeployment }
	| { type: "UpdateDeployment", params: UpdateDeployment }
	| { type: "RenameDeployment", params: RenameDeployment }
	| { type: "CreateBuild", params: CreateBuild }
	| { type: "CopyBuild", params: CopyBuild }
	| { type: "DeleteBuild", params: DeleteBuild }
	| { type: "UpdateBuild", params: UpdateBuild }
	| { type: "CreateBuilder", params: CreateBuilder }
	| { type: "CopyBuilder", params: CopyBuilder }
	| { type: "DeleteBuilder", params: DeleteBuilder }
	| { type: "UpdateBuilder", params: UpdateBuilder }
	| { type: "CreateServerTemplate", params: CreateServerTemplate }
	| { type: "CopyServerTemplate", params: CopyServerTemplate }
	| { type: "DeleteServerTemplate", params: DeleteServerTemplate }
	| { type: "UpdateServerTemplate", params: UpdateServerTemplate }
	| { type: "CreateRepo", params: CreateRepo }
	| { type: "CopyRepo", params: CopyRepo }
	| { type: "DeleteRepo", params: DeleteRepo }
	| { type: "UpdateRepo", params: UpdateRepo }
	| { type: "CreateAlerter", params: CreateAlerter }
	| { type: "CopyAlerter", params: CopyAlerter }
	| { type: "DeleteAlerter", params: DeleteAlerter }
	| { type: "UpdateAlerter", params: UpdateAlerter }
	| { type: "CreateProcedure", params: CreateProcedure }
	| { type: "CopyProcedure", params: CopyProcedure }
	| { type: "DeleteProcedure", params: DeleteProcedure }
	| { type: "UpdateProcedure", params: UpdateProcedure }
	| { type: "CreateTag", params: CreateTag }
	| { type: "DeleteTag", params: DeleteTag }
	| { type: "RenameTag", params: RenameTag }
	| { type: "UpdateTagsOnResource", params: UpdateTagsOnResource }
	| { type: "CreateVariable", params: CreateVariable }
	| { type: "UpdateVariableValue", params: UpdateVariableValue }
	| { type: "UpdateVariableDescription", params: UpdateVariableDescription }
	| { type: "DeleteVariable", params: DeleteVariable };

export type WsLoginMessage = 
	| { type: "Jwt", params: {
	jwt: string;
}}
	| { type: "ApiKeys", params: {
	key: string;
	secret: string;
}};

